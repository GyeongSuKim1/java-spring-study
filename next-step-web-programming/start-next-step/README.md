# 요구사항
- 문자열 계산기의 요구사항은 전달하는 문자를 구분자로 분리한 후 각 숫자의 합을 구해 반환해야 한다.
    - 쉼표(,) 또는 클론(:)을 구분자로 가지는 문자열을 전달하는 경우 구분자를 기준으로 분리한 각 숫자의 합을 반환.
        - (예 " " => 0, "1, 2" => 3, "1, 2, 3" => 6, "1, 2:3" => 6)
    - 앞의 기본 구분자(쉼표, 클론)외에 커스텀 구분자를 지정할 수 있다. 커스텀 구분자는 문자열 앞부분의 "//"와 "\n"사이에 위치하는 문자를 커스텀 구분자로 사용한다.
        - (예 "//;\n1;2;3"과 같이 값을 입력할 경우 커스텀 구분자는 세미콜론(;)이며, 결과 값은 6이 반환되어야 한다.)
    - 문자열 계산기에 음수를 전달하는 경우 RuntimeException으로 예외 처리해야 한다.

## 정리
- #### 구현 순서
1. 각 단계의 개발 과정은 구현
2. 테스트를 통한 결과 확인
3. 리팩토링으로 진행.
- 가능하면 다음 제시한 3원칙을 지코도록 노력하자
    - 메소드가 한 가지 책임만 가지도록 구현
    - 인덴트(indent, 들여쓰기) 깊이를 1단계로 유지
    - else사용 자제
- 리팩토링을 극단적으로 진행함.
    - 이렇게 극단적으로 진행할 수 있었던 이유는 테스크 코드가 있었기 때문
    - 테스트 코드가 있고없고의 차이는 크다
    - 테스트와 리팩토링은 분리할 수 없는 동반자 관계이고 같이 연습하자

<br>

> ## 예외 처리를 따로 메소드로 관리하는 것의 장점
> - 코드의 가독성이 향상됨
> - 코드의 재사용성이 향상됨
> - 코드의 유연성이 향상됨
> ## try-catch블록으로 처리하는 것의 장점
> - 예외 처리의 범위를 제한할 수 있음
> - 예외 처리 코드의 위치가 명확함
> - 예외 처리를 즉시 처리할 수 있음
> > ### 비용적인 측면에선 ?
> > - 예외 처리 방법의 비용적인 측면에서는, 일반적으로 따로 메소드로 관리하는 것이 try-catch 블록으로 처리하는 것보다 더 효율적.
> > - try-catch 블록은 예외가 발생할 때마다 스택 추적 정보를 생성하고, 예외 객체를 생성하는 등의 오버헤드가 발생. 반면에, 예외 처리를 따로 메소드로 분리하면, 예외 처리 코드를 반복해서 호출하는 것이 아니므로, 오버헤드가 줄어듬.
> > - 예외 처리를 따로 메소드로 분리하면, 코드의 재사용성이 향상되어 유지보수 비용이 줄어들 수 있음. 코드 중복을 줄일 수 있으므로, 코드의 복잡성이 줄어들어 유지보수가 쉬워짐.
> > - 따라서, 예외 처리 방법의 비용적인 측면에서 보면, 예외 처리를 따로 메소드로 분리하는 것이 더 좋은 선택.
> > > ### 그러면 try-catch를 사용하기 좋을 때는 ?
> > > - 예외 처리를 즉시 처리해야 하는 경우
        > > >   - 만약 예외 처리를 따로 메소드로 분리하면, 예외가 발생할 때마다 메소드를 호출해야 한다. 이는 오버헤드를 유발하므로, 예외처리를 즉시 처리해야 하는 경우 try-catch블록을 사용하는 것이 좋다.
> > > - 예외 처리 제한을 두는 경우
        > > >   - 예외 처리를 따로 메소드로 분리하면, 예외 처리 코드의 위치가 명확하지 않을수 있다. 따라서, 예외 처리 범위를 제한하기 어려운 경우 try-catch블록을 사용하는 것이 좋다.
> > > - 예외 처리 코드가 간단한 경우
        > > >   - 예외 처리 코드가 간단하고, 예외가 발생할 가능성이 낮은 경우에는 try-catch블록을 사용하는 것이 코드의 가독성을 높일 수 있다.
                  <br> <br>
> > > - 위와 같은 경우엔 try-catch블록을 사용하는 것이 더 적절함. 그러나, 예외 처리 코드가 복잡하고, 예외가 발생할 가능성이 높은 경우에는 예외 처리를 따로 메소드로 분리하는 것이 좋다.